- Title: Goal with State
- Drivers: Enrico

----

# Summary

We extend the type of tactics from
```ocaml
type tactic = goal * evar_map -> goal list * evar_map
```
to
```ocaml
type tactic = goal_w_state * evar_map -> goal_w_state list * evar_map
```
where `goal = Evar.t`, i.e. a key the `evar_map` associates to `evar_info`,
while `goal_w_state = (Evar.t, state)` where `state` is a data type to be discussed.

This change simplifies the storage/update of goal related data. Tactics can
read, write, or ignore the data associated to a goal. The lifetime of the data
is the one of the goal: if a goal is closed, then the data is gone; if the
goal is turned into subgoals, each subgoal inherits the data.

This CEP explains the design/motivation, while https://github.com/coq/coq/pull/6676 
implements the CEP in the current type of tactics.

# Motivation

In the implementaion of SSR intro patterns (especially the extended ones https://github.com/coq/coq/pull/6705)
I found that explicitly threading data to sub tactics is very hard.

Since such data is semantically attached to a goal I used a custom tactic type (the one above) and tactic combinators.
This simplified the code and solved a few bugs. To port SSR to the new type of tactics I want to use the same technique.

## Example that shows the problem

Example: The intro pattern `=> + [ | n] H` on goal
```coq
=====
forall x y, 0 < y -> P x y
```
generates
```coq
H : 0 < 0
======
  forall x, P x 0

2nd goal:
n : nat
H : 0 < S n 
=======
  forall x, P x (S n)
```
The intro pattern reads: temporarily introduce `x`, then destruct the first quantification (`y`) and name `n` the
variable in the second goal, then introduce `H` (in all goals), finally revert `x`.

One can compile the ipat (by hand) to the following code

```ocaml
  tclTHEN (intro_tmp $tmp $x)                                     (* + *)
    (tclTHEN          
      (tclTHENS (tclTHENLIST [intro top; case top; clear top])    (* case *)
        [ idtac; intro n ])                                       (* [ | n ] *)
      (tclTHEN (intro H)                                          (* H *)
        (revert $tmp $x)…)                                        (* + *)                        
```

I used `name` for names (data) that are constant, while `$tmp` for data is
shared among tactics and (in all the cases above) set at its first occurrence,
an used in its second one. Moreover.
- `intro_tmp $tmp $x` saves the name of the bound variable (`x` in this case) in `$x` while the temporary, inaccessible,
   name in `$tmp`.
- `revert $foo $x` reverts `$foo`, clears it, and renames (for pp purposes only) the quantified variable to `$x`.

Note that the compilation is *non compositional*. For example the first tactic `intro_tmp`
has to communicate two names to the last tactic `revert` (they have to be compiled together,
but their position in the resulting tactic is distant). Also note that `revert` will be execued
twice (in this simple case the same `revert` is executed in both branches).  Remark that statically
one does not know on how many goals `revert` will be run, so the data links as `$tmp` are write once,
read many, and write much take place before any read.  

### Things can get even nastyer (skip at the first reading)

Think about the following more complex scenario (HARD1).
If a `+` was used in *one* of the two branches of `[| n]` the temporarily 
introduced variable to be reverted
would only have existed in that goal, not in the other one. The best one could get is 
`tclTHELIST [ revert $tmp $x; try (revert $tmp1 $x1) ]`. 

(HARD2) Another pattern is `case: t => [^ seed ]`. It introduces all variables coming
from the case analisys using the names ginve in the constructors prefixing them
with `seed`. The `case` tactic (the one and the only one that can fetch
from the environment the names of the arguments of the constructors of t)
has to pass such data to `[^ seed ]` a list of lists of names.
A common idiom is `case: t => //= [^ seed ]` that, before the mass-introduction,
simplifies the goals *and* removed some of them (the trivial ones).
So, the list of list of names generated by case and the list of goals
received by `[^ seed ]` may not match anymore (less goals). If the data is attached
the goals, then the implementation is trivial. If the data is explicitly passed
the combinator calling `//=` on each goals has to be aware of the list of names an 
trim it.

## Proposal

To make the compilation compositional I suggest to use
```ocaml
type state = { to_revert : (tmp_name * orig_name) list; ... }
```
such state is inherited by subgoals, for example the execution of `case`
```ocaml
let case hyp ((g,s) * sigma) = ..... ([ (g1,s) ; (g2, s) ], sigma)
```
where `g1` is the goal for `0`, `g2` the goal for `S _`. Note that the state `s` is unchanged, and
(most importantly) attached to both goals. In the execution above
```ocaml
s = { to_revert : [ ("_tmp_x_", "x") ] ; ... }
```
The code of `revert` would then be
```ocaml
let revert_all ((g,{ to_revert }), sigma) =
  let g', sigma = List.fold_right … to_revert (g,sigma) in
  [ g', { to_revert = [] } ], sigma
let intro_tmp ((g, { to_revert }), sigma) =
  …
  [ g', {to_revert = ("_tmp_x_","x") :: to_revert} ], sigma
```
with these building blocks the compilation becomes

```ocaml
  tclTHEN intro_tmp                                              (* + *)
    (tclTHEN
      (tclTHENS (tclTHENLIST [intro top; case top; clear top])   (* case *)
        [ idtac; intro n ])                                      (* [ | n] *)
      (tclTHEN (intro H)                                         (* H *)
        revert_all)…)                                            (* + *)
```

Note that now the complex scenario (HARD) works just fine, since `rever` is called
with the correct set of hyps to be reverted.

# Detailed design

The current type of tactic is the opaque
```ocaml
type 'a tactic
```
The monad passes around the `evar_map` and `comb` (a list of goals).
This list has been made a list of `goal_w_state`.

The type `state` uses the `Store` facility.
I could hardcode the state I need for SSR. But:
1. such state is spread among 2 files, and tactics in one file don't need to see the
   state used by the tactics in the other file.  This is a good separation of concerns.
1. there is not only SSR, the state should be extensible (see below)

Given that the goal state is part of the opauqe type of tactics, it is suffient to
fix the basic combinators to have the state flow with goals. In particular `refine`
is in charge of attaching the state to all sub goals.

# Drawbacks

- The data follows the goal, not the corresponding evar. 
  If a goal is shelved/unshelved it becomes a new goal (the state is first dropped, 
  then reset to an initial, empty, state).
  
  This is the expected semantics in all use cases I have.

# Alternatives

- Use the `store` component of the `evar_info` data type. 
  + This requires the propagation of the state to happen at `Evd.define` time. 
    It seems overkilling, since one has much more evars than goals (just think at all the implicit arguments).
    
- make the datatype `state` visible in the type, e.g. `type 'a goal_w_state = goal * 'a`
  + breaks extensibility unless one uses objects.  It works for simple combinators that could be typed as
    ```ocaml
    type ('a, 'b) tactic = 'a goal_w_state * evar_map -> ('b goal_w_state) list * evar_map
    tclTHEN : ('a,'b) tactic -> ('a,'b) tactic
    ```
    but would not let you combine a tactic that uses `state1` as `'a` with
    another one that uses `state2` as `'a`. One would have to craft
    the type `state1 + state2` and inject both tactics in there.
    
    objects could solve the issue. it is unclear which static benefit one would get.
    
 - To solve (HARD1) one could also abandon the idea and unshare the branches (distribute `intro H; revert ...` into the two branches
   of `[|]`) but this:
   - complicates a bit the compilation
   - rules out some interesting cases, as a `//` that fails if it makes no progress (in any goal, so you really want
     a single call that sees all goals). It is not implemented yet, but it is the only advanage of the current
     multi-goal type of tactic.

- I've no simple alternative implementation of (HARD2). Historically `[^ seed ]` was introduced together
  with the `goal_w_state` thing in the codebase.

# Status

- implemented in the old `V82` type of tactics (used in SSR for a few years, in Coq since 8.7)
- implemented in the new type of tactic together with the port of SSR ( https://github.com/coq/coq/pull/6676 )
- the PR is approved, but I received so many questions on this patch that I wrote the CEP to aswer
- the PR was merged

